<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>照葫芦画瓢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-06T15:42:09.474Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShSx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>eclipse启动耗时统计插件</title>
    <link href="http://yoursite.com/2018/12/06/eclipse%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/12/06/eclipse启动耗时统计插件/</id>
    <published>2018-12-06T12:51:47.000Z</published>
    <updated>2018-12-06T15:42:09.474Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>《深入理解java虚拟机》，Eclipse运行实战调优中使用。</p><p><strong>1、首先我们要先创建一个插件工程。</strong><br>File-&gt;New-&gt;Project-&gt;Plug-in Development-&gt;Plug-in Project<br><img src="/images/eclipse插件创建1.png" alt="Image text"><br><strong>2.点击Next</strong><br><img src="/images/eclipse插件创建2.png" alt="Image text"><br><strong>3.再点击Next，选择Hello，World Command</strong><br><img src="/images/eclipse插件3.png" alt="Image text"><br><strong>4.点击finish，创建的目录结构为</strong><br><img src="/images/eclipse插件5初始目录结构.png" alt="Image text"><br><strong>5.在工程的目录下，建个名为ShowTime的类</strong><br><img src="/images/eclipse插件新建class.png" alt="Image text"><br>该类需要继承IStartup接口，并实现earlyStartup()方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shsx.showtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.jface.dialogs.MessageDialog;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.swt.widgets.Display;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.swt.widgets.Shell;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.ui.IStartup;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 统计Eclipse启动耗时时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> Shsx</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowTime</span> <span class="keyword">implements</span> <span class="title">IStartup</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earlyStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Display.getDefault().syncExec(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//获取eclipse启动的时间</span></span><br><span class="line">                <span class="keyword">long</span> eclipseStartTime = Long.parseLong(System.getProperty(<span class="string">"eclipse.startTime"</span>));</span><br><span class="line">                <span class="comment">//获取系统当前的时间</span></span><br><span class="line">                <span class="keyword">long</span> costTime = System.currentTimeMillis() - eclipseStartTime;</span><br><span class="line">                Shell shell = Display.getDefault().getActiveShell();</span><br><span class="line">                String message = <span class="string">"Eclipse启动耗时  "</span> + costTime + <span class="string">"ms"</span>;</span><br><span class="line">                MessageDialog.openInformation(shell, <span class="string">"Information"</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>6.打开plugin.xml文件，用下面的代码替换，注意class中的路径是你ShowTime类的路径。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;?eclipse version=&quot;3.4&quot;?&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line"></span><br><span class="line"> &lt;extension</span><br><span class="line"> </span><br><span class="line">         point=&quot;org.eclipse.ui.startup&quot;&gt;</span><br><span class="line"> </span><br><span class="line">         &lt;startup class=&quot;com.shsx.showtime.ShowTime&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">   &lt;/extension&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><p><strong>7、测试插件，右击你的工程，点击Run As-&gt;Eclipse Applicaption</strong><br><img src="/images/eclipse插件启动成功.png" alt="Image text"><br><strong>8、导出插件</strong><br>右击你的工程，选择 Export-&gt;Plug-in Development-&gt;Deployable plug-ins and fragments,点击next  在Directory中填写你要导出的路径，点击finish。<br>导出之后是一个名为plugins的文件夹，将文件夹中的Jar包复制到eclipse/plugins目录下即可，再次启动eclipse就可以看到插件生效了。<br><strong>8、插件中文乱码</strong><br>bulid.properties文件后面加上javacDefaultEncoding.. = utf-8，完整文件如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source.. = src/</span><br><span class="line">output.. = bin/</span><br><span class="line">bin.includes = plugin.xml,\</span><br><span class="line">               META-INF/,\</span><br><span class="line">               .,\</span><br><span class="line">               icons/</span><br><span class="line">javacDefaultEncoding.. = utf-<span class="number">8</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;《深入理解java虚拟机》，Eclipse运行实战调优中使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、首先我们要先创建一个插件工程。&lt;/strong&gt;&lt;br&gt;File-&amp;gt;New-&amp;gt;Project-&amp;gt;Plug-in Development-&amp;gt;
      
    
    </summary>
    
      <category term="eclipse插件" scheme="http://yoursite.com/categories/eclipse%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="eclipse插件" scheme="http://yoursite.com/tags/eclipse%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>springboot入门一</title>
    <link href="http://yoursite.com/2018/12/06/springboot%E5%85%A5%E9%97%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2018/12/06/springboot入门一/</id>
    <published>2018-12-06T02:27:07.000Z</published>
    <updated>2018-12-06T02:29:43.412Z</updated>
    
    <content type="html"><![CDATA[<p>进入<a href="https://start.spring.io/，选择maven工程，jdk" target="_blank" rel="noopener">https://start.spring.io/，选择maven工程，jdk</a> 8，点击Generate Project，生成demo工程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进入&lt;a href=&quot;https://start.spring.io/，选择maven工程，jdk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://start.spring.io/，选择maven工程，jdk&lt;/a&gt; 8，点击Generate
      
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>2018-12-6-英文单词</title>
    <link href="http://yoursite.com/2018/12/06/2018-12-6-%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2018/12/06/2018-12-6-英文单词/</id>
    <published>2018-12-06T01:28:53.000Z</published>
    <updated>2018-12-06T12:11:05.679Z</updated>
    
    <content type="html"><![CDATA[<p><strong>parallel</strong><br>英 [ˈpærəlel]   美 [ˈpærəˌlɛl]<br>adj.<br>平行的;相同的，类似的;[电]并联的;[计]并行的<br>adv.<br>平行地，并列地<br>n.<br>平行线（面）;相似物;类比;纬线<br>vt.<br>使平行;与…媲美;与…相比;与…相似<br><strong>scavenge</strong><br>英 [ˈskævɪndʒ]   美 [ˈskævəndʒ]<br>vt.&amp; vi.<br>清除污物，打扫;（在废物中）寻觅;（动物）食腐肉<br><strong>serial</strong><br>英 [ˈsɪəriəl]   美 [ˈsɪriəl]<br>adj.<br>连续的;连载的;顺序排列的;分期偿付的<br>n.<br>连载小说;电视连续剧;定期刊物;[军]行军梯队<br><strong>proxy</strong><br>英 [ˈprɒksi]   美 [ˈprɑ:ksi]<br>n.<br>代理服务器;代表权;代理人，代替物;委托书<br><strong>vendor</strong><br>英[ˈvendə(r)]<br>美[ˈvɛndɚ]<br>n.    卖主; 摊贩，小贩; [贸易] 自动售货机; &lt;正式&gt;供应商;<br>[例句]Remember, the estate agent is working for the vendor.<br>记住，房地产代理商是为房地产卖方服务的。<br>[其他]    复数：vendors</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;parallel&lt;/strong&gt;&lt;br&gt;英 [ˈpærəlel]   美 [ˈpærəˌlɛl]&lt;br&gt;adj.&lt;br&gt;平行的;相同的，类似的;[电]并联的;[计]并行的&lt;br&gt;adv.&lt;br&gt;平行地，并列地&lt;br&gt;n.&lt;br&gt;平行线（面）;相似物;类比;
      
    
    </summary>
    
      <category term="英文" scheme="http://yoursite.com/categories/%E8%8B%B1%E6%96%87/"/>
    
    
      <category term="英文" scheme="http://yoursite.com/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>内存分配和回收策略</title>
    <link href="http://yoursite.com/2018/12/05/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2018/12/05/内存分配和回收策略/</id>
    <published>2018-12-05T12:16:26.000Z</published>
    <updated>2018-12-05T12:46:19.845Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>自动管理内存最终解决两个问题，给对象分配内存以及回收分配给对象的内存<br>大方向来说：<br>对象在堆上分配，主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配。<br>分配的规则不是百分之百固定。</p><h1 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h1><p>大多数情况下，对象在新生代Eden分配，当Eden没有足够的空间进行分配时，虚拟机将发起一次MinorGC、<br>新生代GC（Minor GC），老年代GC（Major GC / Full GC）,Full GC 会比MinorGC慢10倍。</p><h1 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h1><p>参数 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接进入老年代。<br>避免在Eden和两个Survivor之间大量的内存复制</p><h1 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h1><p>虚拟机给每个对象定义一个对象年龄（Age）计数器。<br>如果在Eden出生，并且经过第一次MinorGC 后仍然存活，并且在Survivor容纳的恶化，将被移到Survivor空间中，并且对象<br>年龄设为1，对象在Survivor区每熬过一次Minor GC，年龄就增加1，当年龄到15时（默认），晋升到老年代。<br>对象晋升老年代的年龄阈值参数为 -XX:MaxTenuringThreshold 来设置</p><h1 id="动态的年龄判定"><a href="#动态的年龄判定" class="headerlink" title="动态的年龄判定"></a>动态的年龄判定</h1><p>虚拟机并不是永远要求对象的年龄必须达到15才能晋升老年代，<br>如果Survivor空间相同年龄的对象大小总和大于Survivor的一半，<br>年龄大于或等于该年龄的对象直接进入老年代</p><h1 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h1><p>在发生Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的空间。<br>如果条件成立，Minor GC是安全的。<br>如果不成立，查看HandlepromotionFailure设置值是否允许担保失败<br>如果允许，那么检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，<br>如果大于，进行Minor GC，尽管是有风险的<br>如果小于或者HandlepromotionFailure不允许，改为进行Full GC</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;自动管理内存最终解决两个问题，给对象分配内存以及回收分配给对象的内存&lt;br&gt;大方向来说：&lt;br&gt;对象在堆上分配，主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按照线程优先在TLAB上分配。&lt;br&gt;分配的规则不是百分之百固定。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="http://yoursite.com/2018/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/05/垃圾收集器/</id>
    <published>2018-12-05T11:04:10.000Z</published>
    <updated>2018-12-05T12:10:02.179Z</updated>
    
    <content type="html"><![CDATA[<p>前言：<br>垃圾收集算法是方法论，那么垃圾收集器就是具体的实现。<br>直到今天为止，还没有最好的收集器出现，更没有万能的收集器，我们选择的是对具体应用最合适的收集器。</p><h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>Serial收集器是最基本，发展历史最悠久的收集器<br>在jdk1.3之前，是新生代收集的唯一选择<br>它是一个单线程的收集器，不仅仅是使用一个cpu或者是一个线程<br>更重要的是它进行垃圾收集时，必须暂停其他所有的工作，直到它收集结束<br>“stop the world” 会带给用户不良的体验。所以从jdk1.3到jdk1.7，HotSpot虚拟机开发团队为了消除或者减少<br>工作线程因内存回收而导致停顿的努力一直进行。<br>从Serial到Parallel，再到Concurrent Mark Sweep（CMS）再到Garbage First（G1）<br>越来越优秀，也越来越复杂。用户线程的停顿时间不断在缩短，但是仍然没有办法完全消除<br>Serial收集器并不是老而无用<br>Serial收集器在Client模式先的虚拟机是一个很好的选择，它没有线程交互的开销，可以专心做垃圾收集</p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>ParNew收集器其实是Serial收集器的多线程版本。<br>它可以和CMS收集器配合工作<br>在单核CPU并不一定比Serial收集器好，随着CPU数量的增加，性能是好于Serial收集器的</p><h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>Parallel Scavenge收集器是一个新生代收集器，采用的复制算法，又是并行的多线程收集器<br>CMS收集器关注的是尽可能的缩短垃圾收集时用户线程的停顿时间。<br>Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）<br>吞吐量就是CPU运行用户代码的时间/CPU总消耗时间的比值<br>即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)<br>虚拟机总共运行100分钟，垃圾收集花掉1分钟，吞吐量就是99%<br>Parallel Scavenge收集器有一个自适应调节策略</p><h1 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h1><p>Serial Old收集器是Serial的老年代版本。<br>同样是单线程收集器<br>使用标记-整理算法<br>两大用途：<br>1：在JDK1.5之前，与Parallel Scavenge收集器搭配使用<br>2：作为CMS收集器的后备方案在并发收集发生 Concurrent Mode Failure时使用</p><h1 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h1><p>是Parallel Scavenge收集器老年代收集版本<br>多线程<br>标记——整理算法<br>jdk1.6提供，此之前Parallel Scavenge收集器一直处于尴尬位置</p><h1 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h1><p>CMS（Concurrent Mark Sweep）收集器是一种以获得最短回收停顿时间为目标的收集器<br>基于标记-清除算法实现<br>分为4步：<br>初始标记<br>并发标记<br>重新标记<br>并发清除</p><p>初始标记和重新标记仍需要”Stop the World”.<br>最消耗时间的并发标记和并发清除是可以和用户线程一起工作的。<br>CMS 是一款非常优秀的收集器，有点事并发收集和低停顿<br>缺点：<br>1.CMS收集器资源非常敏感<br>2.CMS收集器无法处理浮动垃圾<br>可能会出现Concurrent Mode Failure失败而导致另一次的Full GC.<br>由于CMS并发清理阶段用户线程还在运行，伴随着程序运行自然还会有新的垃圾不断产生，这部分垃圾<br>出现在标记过程之后，CMS无法再当次收集中处理掉他们，只好等到下一次GC时再清理掉，这部分垃圾就称为浮动垃圾<br>3.CMS是一款基于标记-清除的垃圾回收器。会产生大量空间碎片</p><h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>G1收集器是当今收集器技术发展的最前沿的成果之一。<br>G1是面向服务器端应用的垃圾收集器<br>特点：<br>1.并行与并发<br>2.分代收集<br>3.空间整合，与CMS不同，G1的实现是标记-整理算法<br>4.可预测停顿<br>G1将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念但它们已经不是<br>物理隔离了，它们都是一部分Region（不需要连续）的集合。<br>G1运作的步骤<br>初始标记<br>并发标记<br>最终回收<br>筛选回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前言：&lt;br&gt;垃圾收集算法是方法论，那么垃圾收集器就是具体的实现。&lt;br&gt;直到今天为止，还没有最好的收集器出现，更没有万能的收集器，我们选择的是对具体应用最合适的收集器。&lt;/p&gt;
&lt;h1 id=&quot;Serial收集器&quot;&gt;&lt;a href=&quot;#Serial收集器&quot; class=&quot;
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="http://yoursite.com/2018/12/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/05/垃圾收集算法/</id>
    <published>2018-12-05T10:38:21.000Z</published>
    <updated>2018-12-05T11:03:20.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标记-清楚算法"><a href="#标记-清楚算法" class="headerlink" title="标记-清楚算法"></a>标记-清楚算法</h1><p>最基础的算法是”标记-清楚”（Mark-Sweep）算法。<br>该算法分为标记和清除两个阶段<br>1.标记出所有回收的对象<br>2.标记完成后回收被标记的对象<br>不足：<br>1.效率问题，标记和清除这两个过程效率都不高<br>2.空间问题，清除标记后会产生大量的不连续的内存碎片</p><h1 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h1><p>复制为解决效率问题，将可用内存分为容量大小相等的两块，每次只使用其中一块，当一块用完后，将<br>存活的对象复制到另一块上面，然后再把已使用的内存空间清掉。<br>每次对都对整个半区进行内存回收<br>内存分配时，移动堆顶指针，按顺序分配内存<br>实现简单，运行高效<br>代价：将原来的内存缩小的一半，大家有点高<br>目前的商业虚拟机在内存分配上做了优化，还回收新生代<br>分为了一块较大的Eden区，两块小的Survivor区，比例是8:1:1,当Survivor空间不够，有老年区分配担保</p><h1 id="标记——整理算法"><a href="#标记——整理算法" class="headerlink" title="标记——整理算法"></a>标记——整理算法</h1><p>复制算法在对象存活率比较高时，比较多的复制，会导致效率低下。老年带一般不采用复制算法。<br>标记整理的标记过程和标记清除的一样，但是回收对象的时候，将所有的存活的对象都移动到一段，然后直接清掉边界<br>以外的内存</p><h1 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h1><p>当前的商业虚拟机都采用的分代收集算法。<br>根据对象的存活周期不同，将内存划分为几块。<br>一般将java划分为新生代和老年代<br>新生代用的是复制算法，老年代用的标记-清楚或者标记-整理算法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标记-清楚算法&quot;&gt;&lt;a href=&quot;#标记-清楚算法&quot; class=&quot;headerlink&quot; title=&quot;标记-清楚算法&quot;&gt;&lt;/a&gt;标记-清楚算法&lt;/h1&gt;&lt;p&gt;最基础的算法是”标记-清楚”（Mark-Sweep）算法。&lt;br&gt;该算法分为标记和清除两个阶段&lt;br
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>github使用指南</title>
    <link href="http://yoursite.com/2018/12/05/github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/12/05/github使用指南/</id>
    <published>2018-12-05T03:02:12.000Z</published>
    <updated>2018-12-05T06:24:06.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>创建一个hello world工程在计算机编程中是一个悠久的历史传统。这是一个简单的练习，让你开始学习新的东西。让我们开始使用github吧！<br>你将学会什么：<br>创建和使用GitHub仓库<br>启动和管理一个新的分支<br>对文件进行更改，提交并且推送到github<br>打开并合并一个请求</p><h1 id="github是什么？"><a href="#github是什么？" class="headerlink" title="github是什么？"></a>github是什么？</h1><p>github是用于版本控制和协作的代码托管平台。它可以让你和其他人一起从任何地方参与项目。<br>本教程教您GitHub的基本知识，如存储库、分支、提交和拉请求。您将创建自己的Hello World存储库，并学习GitHub的Pull Request工作流，这是一种创建和审查代码的流行方法。</p><h3 id="本教程不需要编程"><a href="#本教程不需要编程" class="headerlink" title="本教程不需要编程"></a>本教程不需要编程</h3><p>完成本教程，你需要一github.com帐户和互联网接入。你不需要知道如何编码，使用命令行，或安装Git的版本控制软件是一个内置的GitHub上）。<br><strong>提示：在单独的浏览器窗口（或选项卡）中打开这个指南，这样在完成本教程中的步骤时可以看到它。</strong></p><h1 id="第一步：创建存储库"><a href="#第一步：创建存储库" class="headerlink" title="第一步：创建存储库"></a>第一步：创建存储库</h1><p>存储库通常用于组织单个项目。存储库可以包含文件夹和文件、图像、视频、电子表格和数据集——项目需要的任何内容。我们建议包括一个自述文件，或者一个包含您项目的信息的文件。GITHUB使您在创建新的存储库的同时添加以上信息是一件简单的事情。它还提供其他常见选项，如许可证文件。<br>您的hello-world存储库可以是存储好的想法、资源、甚至与其他人共享和讨论事情的地方。</p><h2 id="创建一个新的存储库"><a href="#创建一个新的存储库" class="headerlink" title="创建一个新的存储库"></a>创建一个新的存储库</h2><p>1.点击右上角的+号，选择New repository.<br>2.仓库的名字叫做hello-world<br>3.填写项目简介<br>4.选择初始仓库的时候是否生成 README文件<br>点击Create repository. </p><h1 id="第二步：创建一个分支"><a href="#第二步：创建一个分支" class="headerlink" title="第二步：创建一个分支"></a>第二步：创建一个分支</h1><p>分支可以在同一个库不同版本之间工作。<br>未完成。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;创建一个hello world工程在计算机编程中是一个悠久的历史传统。这是一个简单的练习，让你开始学习新的东西。让我们开始使用github吧
      
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/categories/github/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>2018/12/5英文单词学习</title>
    <link href="http://yoursite.com/2018/12/05/2018-12-5%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/12/05/2018-12-5英文单词学习/</id>
    <published>2018-12-05T02:41:18.000Z</published>
    <updated>2018-12-05T06:27:03.416Z</updated>
    
    <content type="html"><![CDATA[<p><strong>verify</strong><br>美[ˈvɛrəˌfaɪ] 英[ˈverɪfaɪ]<br>vt.    核实; 证明; 判定;<br>[例句]I verified the source from which I had that information<br>我核实了我所获消息的来源。<br>[其他]    第三人称单数：verifies 现在分词：verifying 过去式：verified 过去分词：verified</p><p>How would you describe your level of programming experience?<br>如何描述你的编程水平？<br>Very experienced 非常有经验<br>Somewhat experienced 有点经验<br>Totally new to programming 新手<br><strong>hobbyist</strong><br>英 [ˈhɒbiɪst]   美 [ˈhɑ:biɪst]<br>n.<br>沉溺于某种癖好者，嗜某爱好成癖的人</p><p>profile<br>英 [ˈprəʊfaɪl]   美 [ˈproʊfaɪl]<br>n.<br>侧面，半面;外形，轮廓;[航]翼型;人物简介<br>vt.<br>描…的轮廓;给…画侧面图;为（某人）写传略;[机]铣出…的轮廓</p><p>your profile 你的简介</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;verify&lt;/strong&gt;&lt;br&gt;美[ˈvɛrəˌfaɪ] 英[ˈverɪfaɪ]&lt;br&gt;vt.    核实; 证明; 判定;&lt;br&gt;[例句]I verified the source from which I had that information&lt;
      
    
    </summary>
    
      <category term="英文" scheme="http://yoursite.com/categories/%E8%8B%B1%E6%96%87/"/>
    
    
      <category term="英文" scheme="http://yoursite.com/tags/%E8%8B%B1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>k8s培训</title>
    <link href="http://yoursite.com/2018/12/04/k8s%E5%9F%B9%E8%AE%AD/"/>
    <id>http://yoursite.com/2018/12/04/k8s培训/</id>
    <published>2018-12-04T02:14:37.000Z</published>
    <updated>2018-12-04T03:13:26.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用k8s"><a href="#为什么要用k8s" class="headerlink" title="为什么要用k8s"></a>为什么要用k8s</h1><p>rancher ，k8s，docker原生，</p><h1 id="k8s多master的安装"><a href="#k8s多master的安装" class="headerlink" title="k8s多master的安装"></a>k8s多master的安装</h1><p>kube-controller—manager  有很多controller，私有云搭建使用这个<br>cloud-controller—manager 近期出现的版本，给云供应商来控制<br>kube-apiserver 通信的接口，对内通信还有通过<br>etcd 元数据存了那些信息<br>kube-sheduler<br>所有的数据的存储，通过kube-apiserver沟通<br>kubelet<br>kube-proxy<br>1.k8s cluster 所有元数据都存在etcd cluter中<br>2.所有元数据的存储都通过API server来实现的<br>总结manager用来管理</p><h1 id="k8s的常用概念"><a href="#k8s的常用概念" class="headerlink" title="k8s的常用概念"></a>k8s的常用概念</h1><h1 id="架构与运维路线图"><a href="#架构与运维路线图" class="headerlink" title="架构与运维路线图"></a>架构与运维路线图</h1><h1 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h1><p>ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。<br>ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：<br>(1)、连接插件connection plugins：负责和被监控端实现通信；<br>(2)、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；<br>(3)、各种模块核心模块、command模块、自定义模块；<br>(4)、借助于插件完成记录日志邮件等功能；<br>(5)、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。</p><h1 id="k8s-架构——常用概念"><a href="#k8s-架构——常用概念" class="headerlink" title="k8s 架构——常用概念"></a>k8s 架构——常用概念</h1><ol><li>只能在单个主机上运行，跨主机通讯需要使用多个端口映射<br>2.pod  多个容器可以使用同一ip地址</li><li>网络<br>flannel<br>calico<br>4.coredns<br>每个服务都是唯一的域名</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用k8s&quot;&gt;&lt;a href=&quot;#为什么要用k8s&quot; class=&quot;headerlink&quot; title=&quot;为什么要用k8s&quot;&gt;&lt;/a&gt;为什么要用k8s&lt;/h1&gt;&lt;p&gt;rancher ，k8s，docker原生，&lt;/p&gt;
&lt;h1 id=&quot;k8s多master的
      
    
    </summary>
    
      <category term="k8s" scheme="http://yoursite.com/categories/k8s/"/>
    
    
      <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>对象已死？</title>
    <link href="http://yoursite.com/2018/12/03/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2018/12/03/垃圾收集器与内存分配策略/</id>
    <published>2018-12-03T12:06:00.000Z</published>
    <updated>2018-12-05T12:15:32.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h1><p>给对象添加一个引用计数器，每当一个地方引用的时候，计数器加1，引用失效，计数器减1，任何时刻，计数器为0，<br>则则对象不可能在被使用。<br>此算法的问题：难以解决相互引用问题。<br>objA有一个属性引用了objB,objB有一个属性引用了objA，如果外界没有objA和objB的引用，则这两个对象就应该被回收。</p><h1 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h1><p>基本思路是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始往下搜索，搜索走过的路径称为引用链（Reference Chain），<br>当一个对象到GC Roots没有任何引用链相连（称GC Roots 到这个对象不可达）时，则证明此对象不可用，可回收。<br>java中，可作为GC Roots的对象包括以下几种：<br>1.虚拟机栈（栈帧中的本地变量表）中引用的对象<br>2.方法区中静态属性引用的对象<br>3.方法区中常量引用的对象<br>4.本地方法栈中JNI引用的对象</p><h1 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h1><p>JDK1.2以前，java的引用定义：<br>如果reference类型的数据中存储的数据代表的是另一块数据内存的起始地址，就称为这块内存代表着一个引用。</p><p>JDK1.2之后，java对引用进行了扩充，强引用（Strong Reference）,软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）4种，这4种强度依次减弱。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用普遍存在，类似Object obj=new Object(),只要强引用还存在，垃圾回收器永远不会回收掉引用的对象。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>描述一些还有用带不是必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。<br>如果还没有足够的内存，再抛出异常。JDK1.2之后，提供了SoftReference类来实现软引用</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用也是用来描述非必须对象的，它比软引用更弱一些，被弱引用引用的对象只能生存到下次垃圾收集之前。当垃圾收集器工作时，<br>无论当前内存是否足够，都会回收掉直被弱引用关联的对象。JDK1.2之后，通过WeakReference类来实现弱引用。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用称为幽灵引用或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。<br>也不能通过虚引用来取得一个对象实例。唯一的目的是对象被回收的时候可以收到一个系统通知。<br>JDK1.2以后通过PhantomReference来实现虚引用</p><h1 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h1><p>在可达性分析算法中不可达的对象，必须经历两次标记的过程才会被回收。<br>对象进行可达性分析后发现不可达，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize()方法或finalize()已经被虚拟机调用过，虚拟机将这两种情况视为”没必要执行”。<br>如果对象被判定为有必要执行finalize(),则将会将该对象放入一个队列。单独起一个线程调用队列中的finalize()方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h1&gt;&lt;p&gt;给对象添加一个引用计数器，每当一个地方引用的时候，计数器加1，引用失效，计数器减1，任何时刻，计数器为0，&lt;
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java内存区域</title>
    <link href="http://yoursite.com/2018/12/03/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/12/03/java内存区域/</id>
    <published>2018-12-03T10:53:24.000Z</published>
    <updated>2018-12-03T12:03:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程私有</p><h2 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h2><p>线程私有</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>线程私有</p><h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><p>线程公有</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据<br>线程公有（又称为永久代）<br>运行时常量池（Runtime Constant Pool）是方法去的一部分，用于存放编译器的各种字面量和符号引用。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）不是虚拟机运行数据的一部分，也不是java虚拟机滚翻中定义的区域<br>在JDK1.4中新加入的NIO（New Input/Output）,引入了一种基于通道与缓冲区的I/O方式，可以使用Native<br>方式直接分配内存，然后通过一个存储在java堆中的DirectBuffer对象作为这块内存的的引用进行操作。<br>为了提高性能，避免在Java对和Native堆中来回复制。<br>直接内存不受java堆大小的限制，但是会受到本机内存大小的限制。</p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>new 指令之后，先检查后面的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用是否已经加载解析和初始化过<br>如果没有，先执行子昂用的类加载过程。<br>类加载检查通过后，虚拟机为新生的对象分配内存<br>分配内存有三种方式<br>指针碰撞（Bump the Pionter）<br>所有用过的内存放在一边，空闲的放在一边，中间放一个指针作为分界点的指示器，分配内存的时候将指针向空闲区域移动<br>空闲列表（Free List）<br>虚拟机维护一个列表，记录那部分内存可用，那部分内存不可用，分配内存的时候找一块足够大的空间划分给对象实例<br>本地线程缓存（Thread Local Allocation Buffer）</p><p>如果对象在虚拟中创建频繁，如何进行同步<br>1.虚拟机采用CAS配上失败重试的方式保证更新操作的原子性<br>2.把分配内存的操作按照线程进行划分不同的区域，每个线程在Java堆中先预先分配一小块内存称为本地线程缓存，当用完了TLAB，在进行同步锁定，可通过-XX:+/-useTLAB参数来设定</p><p>分配完内存后，虚拟机将分配到的内存初始化为零值（不包括对象头），这一步保证对象不进行初始化也可以使用</p><p>接下来，虚拟机要对对象头进行必要的设置，如 类的元数据信息，对象的哈希码，对象的GC分代年龄，是否启用偏向锁等</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中的存储布局分为3中：<br>1.对象头（Header）<br>对象都存两部分<br>一部分用于存储对象自身运行时数据，如哈希码（hashCode），GC分代年龄，锁状态标志，线程持有锁，偏向线程ID，偏向时间戳等<br>这部分数据的长度在32位和64位虚拟机中大小分别为32和64.此区域会根据一些参数的启用来复用存储空间。<br>另一部分是类型指针，通过指针可以确定对象是哪个实例，但并不是所有的虚拟机实现都必须在对象数据上保留类型指针<br>2.实例数据（Instance Data）<br>对象真正存储的有效信息，也就是各个字段的内容，包括父类的<br>3.对其填充（Padding）<br>没有特别的意义，仅仅起占位符的作用。HotSpotVM的自动管理内存系统要求对象的大小必须是8字节的整倍数</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>1.句柄访问<br>java堆划分出了一块内存作为句柄池，reference存储的是对象句柄池的地址，<br>句柄池包含了对象实例数据（java堆）和类型数据（方法区）的地址<br>2.直接指针<br>reference存储的是对象的地址<br>好处是速度快，Sun HotSpot 使用的是直接指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h1&gt;&lt;h2 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>2018/12/3要做的事情清单</title>
    <link href="http://yoursite.com/2018/12/03/2018-12-3%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%E6%B8%85%E5%8D%95/"/>
    <id>http://yoursite.com/2018/12/03/2018-12-3要做的事情清单/</id>
    <published>2018-12-03T02:19:30.000Z</published>
    <updated>2018-12-03T11:05:39.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="9-00-11：30-工作"><a href="#9-00-11：30-工作" class="headerlink" title="9:00-11：30 工作"></a>9:00-11：30 工作</h3><h3 id="11-30-12-00-吃饭"><a href="#11-30-12-00-吃饭" class="headerlink" title="11.30-12:00 吃饭"></a>11.30-12:00 吃饭</h3><h3 id="12-00-13：30-中间学习10个英文单词或英文语句，休息"><a href="#12-00-13：30-中间学习10个英文单词或英文语句，休息" class="headerlink" title="12:00-13：30 中间学习10个英文单词或英文语句，休息"></a>12:00-13：30 中间学习10个英文单词或英文语句，休息</h3><p>Guard well your thoughts when alone and your words when accompanied.<br>独处守住心，群处守住嘴<br>guard 英 [gɑ:d]   美 [gɑ:rd]<br>n.<br>警卫;狱吏，看守;护卫队;防护装置<br>vt.<br>看守;保卫，守护;加防护装置;谨慎使用<br>vi.<br>警卫;警惕</p><p>accompanied<br>v.<br>陪同;陪伴( accompany的过去式和过去分词 );伴随…同时发生;伴奏</p><p>Courage isn’t having the strength to go on.<br>It’s going on when you don’t have strength.<br>勇气不是有力气坚持下去，而是即使没有力气依然能够坚持。</p><p>courage<br>英 [ˈkʌrɪdʒ]   美 [ˈkɜ:rɪdʒ]<br>n.<br>勇气;胆量;魄力;肝胆</p><p>strength<br>英 [streŋθ]   美 [strɛŋkθ, strɛŋθ, strɛnθ]<br>n.<br>力量;优点，长处;（光、声、色等的）力度;人力[数]</p><p>going on 发生; 接近，快到<br>Direct Memory 直接内存<br>NIO  New Input/Output<br>channel 通道<br>buffer 缓冲区</p><h3 id="13：30-17-00-工作"><a href="#13：30-17-00-工作" class="headerlink" title="13：30-17:00 工作"></a>13：30-17:00 工作</h3><h3 id="17：00-19-00-一天总结，看java虚拟机这本书，并写一篇博客"><a href="#17：00-19-00-一天总结，看java虚拟机这本书，并写一篇博客" class="headerlink" title="17：00-19:00 一天总结，看java虚拟机这本书，并写一篇博客"></a>17：00-19:00 一天总结，看java虚拟机这本书，并写一篇博客</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;9-00-11：30-工作&quot;&gt;&lt;a href=&quot;#9-00-11：30-工作&quot; class=&quot;headerlink&quot; title=&quot;9:00-11：30 工作&quot;&gt;&lt;/a&gt;9:00-11：30 工作&lt;/h3&gt;&lt;h3 id=&quot;11-30-12-00-吃饭&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="清单" scheme="http://yoursite.com/categories/%E6%B8%85%E5%8D%95/"/>
    
    
      <category term="清单" scheme="http://yoursite.com/tags/%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>java线程安全与锁优化</title>
    <link href="http://yoursite.com/2018/11/30/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/11/30/java线程安全与锁优化/</id>
    <published>2018-11-30T10:31:25.000Z</published>
    <updated>2018-11-30T12:41:14.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="1-互斥同步"><a href="#1-互斥同步" class="headerlink" title="1.互斥同步"></a>1.互斥同步</h2><p>互斥同步是是常见的一种并发正确性保障手段。<br>同步是指在在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用。<br>互斥是实现同步的一种手段<br>互斥的实现三种方式</p><ol><li>临界区</li><li>互斥量</li><li>信号量</li></ol><h3 id="java-中最基本的互斥同步手段是使用synchronized"><a href="#java-中最基本的互斥同步手段是使用synchronized" class="headerlink" title="java 中最基本的互斥同步手段是使用synchronized"></a>java 中最基本的互斥同步手段是使用synchronized</h3><p>synchronized被编译后，同步块前后会形成monitorenter和monitorexit这两个字节码指令，<br>这两个指令都需要一个reference类型的参数来指定锁定和解锁的对象<br>如果synchronized指定了对象参数，那就是这个对象的reference<br>如果没有指定，根据修饰的是类方法还是实例方法类确定<br>修饰的类方法：Class对象<br>实例方法：对象实例</p><h3 id="使用java-util-concurrent下的ReentrantLock（重入锁）"><a href="#使用java-util-concurrent下的ReentrantLock（重入锁）" class="headerlink" title="使用java.util.concurrent下的ReentrantLock（重入锁）"></a>使用java.util.concurrent下的ReentrantLock（重入锁）</h3><p>ReentrantLock相对与synchronized的增强</p><h5 id="等待可中断"><a href="#等待可中断" class="headerlink" title="等待可中断"></a>等待可中断</h5><p>是指当持有锁的线程长时间不释放锁的时候，正在等待的线程可以选择放弃等待，去做其他的事情。</p><h5 id="可实现公平锁"><a href="#可实现公平锁" class="headerlink" title="可实现公平锁"></a>可实现公平锁</h5><p>是指多个线程在等待同一个锁的时候，必须按着申请锁的时间顺序依次获取锁。synchronized和ReentrantLock默认是非公平锁</p><h5 id="锁可以绑定多个条件"><a href="#锁可以绑定多个条件" class="headerlink" title="锁可以绑定多个条件"></a>锁可以绑定多个条件</h5><p>synchronized锁对象的wait(),notify(),notifyAll()方法可以实现一个隐含的条件。想要增加条件关联，必须增加锁。<br>而ReentrantLock只需要new Condition()即可<br>jdk1.5版本ReentrantLock的吞吐量是优于synchronized的<br>jdk1.6做了优化，提倡在synchronized能实现的情况下，优先使用synchronized</p><h2 id="2-非阻塞同步"><a href="#2-非阻塞同步" class="headerlink" title="2.非阻塞同步"></a>2.非阻塞同步</h2><p><strong>互斥同步主要是线程阻塞和唤醒所带来的性能问题，所有这种同步也成为阻塞同步</strong><br>从处理问题的方式来看，互斥同步属于一种<strong>悲观并发策略</strong>，总是认为只要不同步，就会出现问题<br>另一种方式是基于冲突检测的<strong>乐观并发策略</strong>，假设没有冲突，先进行操作，如果没有其他线程争用共享数据，<br>则操作成功，如果有，产生了冲突，采用补偿机制，最常用的补偿机制是<strong>(不断重试，直到成功为止)</strong><br>最常用的技术就是<strong>CAS（Compare-and—Swap）</strong><br>CAS有三个值<br>V(内存地址)<br>A(旧的预期值)<br>B(新值)<br>当且仅当V符合旧的预期值A时，处理器用新的B更新V的值，否则不会更新，但是无论是否更新，都会返回V的旧值。</p><p>CAS有个漏洞<strong>ABA</strong>问题，可通过为值加版本号来解决</p><h2 id="3-无同步方案"><a href="#3-无同步方案" class="headerlink" title="3.无同步方案"></a>3.无同步方案</h2><p><strong>可重入代码</strong><br>如果一个方法，结果是可预测的，输入相同的数据，返回相同的结果，它就满足可重入性的要求，也就是线程安全的<br><strong>线程本地存储</strong><br>如果一个变量要被多线程访问，可以使用volatile关键字声明它为”易变的”<br>如果一个变量要被某线程独享，可以使用ThreadLocal，使用线程池的时候一定要注意线程复用问题</p><h1 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h1><h2 id="1-自旋锁和自适应自旋"><a href="#1-自旋锁和自适应自旋" class="headerlink" title="1.自旋锁和自适应自旋"></a>1.自旋锁和自适应自旋</h2><h2 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2.锁消除"></a>2.锁消除</h2><h2 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3.锁粗化"></a>3.锁粗化</h2><h2 id="4-轻量级锁"><a href="#4-轻量级锁" class="headerlink" title="4.轻量级锁"></a>4.轻量级锁</h2><h2 id="5-偏向锁"><a href="#5-偏向锁" class="headerlink" title="5.偏向锁"></a>5.偏向锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程安全的实现方法&quot;&gt;&lt;a href=&quot;#线程安全的实现方法&quot; class=&quot;headerlink&quot; title=&quot;线程安全的实现方法&quot;&gt;&lt;/a&gt;线程安全的实现方法&lt;/h1&gt;&lt;h2 id=&quot;1-互斥同步&quot;&gt;&lt;a href=&quot;#1-互斥同步&quot; class=&quot;head
      
    
    </summary>
    
      <category term="线程安全" scheme="http://yoursite.com/categories/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库三大范式</title>
    <link href="http://yoursite.com/2018/11/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/11/27/数据库三大范式/</id>
    <published>2018-11-27T10:52:26.000Z</published>
    <updated>2018-11-27T13:09:40.768Z</updated>
    
    <content type="html"><![CDATA[<p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越良好结构的数据库，可以减少数据冗余。</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><p>所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，<strong>即数据库表的每一列都是不可分割的原子数据项</strong>，而不能是集合，数组，记录等非原子数据项。<br>什么叫做不可分割的原子项，比如有个<br>用户信息表：</p><table><thead><tr><th>用户编号</th><th>姓名</th><th>专业</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>兰州理工大学软件工程</td></tr><tr><td>2</td><td>李四</td><td>兰州龚家湾技校挖土机专业</td></tr></tbody></table><p>我想找兰州龚家湾技校的人，直接查询专业是不方便的，按照我目前的需求，<br>所以专业这个列还可以接着再拆分</p><table><thead><tr><th>用户编号</th><th>姓名</th><th>学校</th><th>专业名称</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>兰州理工大学</td><td>软件工程</td></tr><tr><td>2</td><td>李四</td><td>兰州龚家湾技校</td><td>挖土机专业</td></tr></tbody></table><p>这样就不错了，我想找按照学校过滤就方便多了</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><p>第二范式（2NF）<strong>要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，</strong>如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，<strong>第二范式就是在第一范式的基础上属性完全依赖于主键</strong>。<br>比如我们在填报志愿（此处是假设，与现实填报志愿不符）的时候，我们的<strong>学生编号，学校编号，专业编号可以组成联合主键</strong>，可以确定一个填报志愿</p><p>申请志愿表</p><table><thead><tr><th>学生编号</th><th>姓名</th><th>学校编号</th><th>学校名称</th><th>学校邮编</th><th>专业编号</th><th>专业名称</th><th>填报时间</th><th>是否服从调剂</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>1</td><td>兰州理工大学</td><td>247000</td><td>1</td><td>软件工程</td><td>2014-6-25</td><td>否</td></tr><tr><td>2</td><td>李四</td><td>2</td><td>山东蓝翔技校</td><td>349000</td><td>2</td><td>挖土机专业</td><td>2014-6-26</td><td>否</td></tr></tbody></table><p>学生名称部分依赖于学生编号，学校邮编和学校名称部分依赖于学校编号，专业名称部分依赖于专业编号</p><p>下面我们对申请志愿表按照第二范式进行拆分</p><p>学生表</p><table><thead><tr><th>学生编号</th><th>姓名</th></tr></thead><tbody><tr><td>1</td><td>张三</td></tr><tr><td>2</td><td>李四</td></tr></tbody></table><p>学校表</p><table><thead><tr><th>学校编号</th><th>学校名称</th><th>学校邮编</th></tr></thead><tbody><tr><td>1</td><td>兰州理工大学</td><td>247000</td></tr><tr><td>2</td><td>山东蓝翔技校</td><td>349000</td></tr><tr><td>3</td><td>兰州龚家湾技校</td><td>249997</td></tr></tbody></table><p>专业表</p><table><thead><tr><th>专业编号</th><th>专业名称</th></tr></thead><tbody><tr><td>1</td><td>软件工程</td></tr><tr><td>2</td><td>挖土机专业</td></tr></tbody></table><p>新的申请志愿表</p><table><thead><tr><th>学生编号</th><th>学校编号</th><th>专业编号</th><th>填报时间</th><th>是否服从天调剂</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>2014-6-25</td><td>否</td></tr><tr><td>2</td><td>2</td><td>2</td><td>2014-6-25</td><td>否</td></tr></tbody></table><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><p>在2NF基础上，<strong>任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖</strong><br>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。<br>简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。<br>假设我们的申请志愿表有个<strong>唯一编号作为主键，即志愿编号</strong></p><p><strong>非主属性学校名称是依赖于非主属性学校编号的，还有专业名称依赖于专业编号等</strong><br>申请志愿表</p><table><thead><tr><th>志愿编号</th><th>学生编号</th><th>姓名</th><th>学校编号</th><th>学校名称</th><th>学校邮编</th><th>专业编号</th><th>专业名称</th><th>填报时间</th><th>是否服从调剂</th></tr></thead><tbody><tr><td>001</td><td>1</td><td>张三</td><td>1</td><td>兰州理工大学</td><td>247000</td><td>1</td><td>软件工程</td><td>2014-6-25</td><td>否</td></tr><tr><td>002</td><td>2</td><td>李四</td><td>2</td><td>山东蓝翔技校</td><td>349000</td><td>2</td><td>挖土机专业</td><td>2014-6-26</td><td>否</td></tr></tbody></table><p>所以学校表，专业表拆分和第二范式类似</p><p>新的申请志愿表</p><table><thead><tr><th>志愿编号</th><th>学生编号</th><th>学校编号</th><th>专业编号</th><th>填报时间</th><th>是否服从天调剂</th></tr></thead><tbody><tr><td>001</td><td>1</td><td>1</td><td>1</td><td>2014-6-25</td><td>否</td></tr><tr><td>002</td><td>2</td><td>2</td><td>2</td><td>2014-6-25</td><td>否</td></tr></tbody></table><p>其他表的拆分与第二范式相同，第三范式其实是第二范式的一个子集，满足三范式就一定满足第二范式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越良好结构的数据库，可以减少数据冗余。&lt;/p&gt;
&lt;h1 id=&quot;第一范式&quot;&gt;&lt;a href=&quot;#第一范式&quot; class=&quot;header
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CAP原则</title>
    <link href="http://yoursite.com/2018/11/26/CAP%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/11/26/CAP原则/</id>
    <published>2018-11-26T14:12:50.000Z</published>
    <updated>2018-11-26T15:23:35.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h1><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳：<br>● 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）<br>● 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）<br>● 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p><h2 id="与可用的决择"><a href="#与可用的决择" class="headerlink" title="与可用的决择"></a>与可用的决择</h2><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。<br>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CAP原则&quot;&gt;&lt;a href=&quot;#CAP原则&quot; class=&quot;headerlink&quot; title=&quot;CAP原则&quot;&gt;&lt;/a&gt;CAP原则&lt;/h1&gt;&lt;p&gt;CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>查看端口被进程占用</title>
    <link href="http://yoursite.com/2018/11/26/%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E8%BF%9B%E7%A8%8B%E5%8D%A0%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/26/查看端口被进程占用/</id>
    <published>2018-11-26T08:49:33.000Z</published>
    <updated>2018-11-26T09:03:50.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><p>查询20880被谁占用，在任务管理器找到相关进程（pid），结束任务即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lenovo&gt;netstat -aon|findstr &quot;20880&quot;</span><br><span class="line">                                                                       pid                              </span><br><span class="line">  TCP    0.0.0.0:20880          0.0.0.0:0              LISTENING       15744</span><br><span class="line">  TCP    10.6.252.40:20880      10.6.252.40:62321      ESTABLISHED     15744</span><br><span class="line">  TCP    10.6.252.40:20880      10.6.252.40:62422      ESTABLISHED     15744</span><br><span class="line">  TCP    10.6.252.40:62321      10.6.252.40:20880      ESTABLISHED     11308</span><br><span class="line">  TCP    10.6.252.40:62422      10.6.252.40:20880      ESTABLISHED     2536</span><br><span class="line">  TCP    [::]:20880             [::]:0                 LISTENING       15744</span><br></pre></td></tr></table></figure></p><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><p>netstat -tunlp |grep 端口号，用于查看指定的端口号的进程情况，如查看80端口的情况，netstat -tunlp |grep 80<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze88p52tbioqel09nmrz ~]# netstat -tunlp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      20618/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1138/sshd</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      20618/nginx: master</span><br><span class="line">udp        0      0 0.0.0.0:57373           0.0.0.0:*                           706/dhclient</span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           706/dhclient</span><br><span class="line">udp        0      0 172.17.66.158:123       0.0.0.0:*                           806/ntpd</span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                           806/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           806/ntpd</span><br><span class="line">udp6       0      0 :::53341                :::*                                706/dhclient</span><br><span class="line">udp6       0      0 :::123                  :::*                                806/ntpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iz2ze88p52tbioqel09nmrz ~]# netstat -tunlp | grep 80</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      20618/nginx: master</span><br><span class="line">tcp6       0      0 :::80                   :::*                    LISTEN      20618/nginx: master</span><br><span class="line">udp        0      0 172.17.66.158:123       0.0.0.0:*                           806/ntpd</span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                           806/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           806/ntpd</span><br><span class="line">udp6       0      0 :::123                  :::*                                806/ntpd</span><br></pre></td></tr></table></figure></p><p>说明一下几个参数的含义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-t (tcp) 仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化为数字</span><br><span class="line">-l 仅列出在Listen(监听)的服务状态</span><br><span class="line">-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure></p><p>如果想解除端口占用 kill PID<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 20618</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;windows&quot;&gt;&lt;a href=&quot;#windows&quot; class=&quot;headerlink&quot; title=&quot;windows&quot;&gt;&lt;/a&gt;windows&lt;/h1&gt;&lt;p&gt;查询20880被谁占用，在任务管理器找到相关进程（pid），结束任务即可&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>spring源码赏析二</title>
    <link href="http://yoursite.com/2018/11/25/spring%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/11/25/spring源码赏析二/</id>
    <published>2018-11-25T10:35:18.000Z</published>
    <updated>2018-11-25T11:37:43.192Z</updated>
    
    <content type="html"><![CDATA[<p>如果想要学习一个框架，第一步就是如何入手。怎样阅读spring源码呢，当然是从测试类入手啦！！！spring提供了非常全面的测试类，今天就从srping-beans.jar的RequiredAnnotationBeanPostProcessorTests测试类入手<br>下面是testWithRequiredPropertyOmitted方法源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testWithRequiredPropertyOmitted() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</span><br><span class="line">BeanDefinition beanDef = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RequiredTestBean.class)</span><br><span class="line">.addPropertyValue(&quot;name&quot;, &quot;Rob Harrop&quot;)</span><br><span class="line">.addPropertyValue(&quot;favouriteColour&quot;, &quot;Blue&quot;)</span><br><span class="line">.addPropertyValue(&quot;jobTitle&quot;, &quot;Grand Poobah&quot;)</span><br><span class="line">.getBeanDefinition();</span><br><span class="line">factory.registerBeanDefinition(&quot;testBean&quot;, beanDef);</span><br><span class="line">factory.addBeanPostProcessor(new RequiredAnnotationBeanPostProcessor());</span><br><span class="line">factory.preInstantiateSingletons();    //在此抛出了异常</span><br><span class="line">fail(&quot;Should have thrown BeanCreationException&quot;);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanCreationException ex) &#123;</span><br><span class="line">String message = ex.getCause().getMessage();</span><br><span class="line">assertTrue(message.contains(&quot;Property&quot;));</span><br><span class="line">assertTrue(message.contains(&quot;age&quot;));</span><br><span class="line">assertTrue(message.contains(&quot;testBean&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RequiredTestBean.java<br>注意age属性必须要注入的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public static class RequiredTestBean implements BeanNameAware, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">private String favouriteColour;</span><br><span class="line"></span><br><span class="line">private String jobTitle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Required</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@MyRequired</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getFavouriteColour() &#123;</span><br><span class="line">return favouriteColour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Required</span><br><span class="line">public void setFavouriteColour(String favouriteColour) &#123;</span><br><span class="line">this.favouriteColour = favouriteColour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getJobTitle() &#123;</span><br><span class="line">return jobTitle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Required</span><br><span class="line">public void setJobTitle(String jobTitle) &#123;</span><br><span class="line">this.jobTitle = jobTitle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Required</span><br><span class="line">public void setBeanName(String name) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">@Required</span><br><span class="line">public void setBeanFactory(BeanFactory beanFactory) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static RequiredTestBean create() &#123;</span><br><span class="line">return new RequiredTestBean();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="RequiredAnnotationBeanPostProcessor-java-主要是这个处理类来做事情，"><a href="#RequiredAnnotationBeanPostProcessor-java-主要是这个处理类来做事情，" class="headerlink" title="RequiredAnnotationBeanPostProcessor.java 主要是这个处理类来做事情，"></a>RequiredAnnotationBeanPostProcessor.java 主要是这个处理类来做事情，</h1><p>代码太多，我贴出来最重要的一个方法，异常也是该方法抛出的，<strong>这是程序抛出异常的最后一步</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">if (!this.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">if (!shouldSkip(this.beanFactory, beanName)) &#123;</span><br><span class="line">List&lt;String&gt; invalidProperties = new ArrayList&lt;String&gt;();</span><br><span class="line">for (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">if (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">invalidProperties.add(pd.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">throw new BeanInitializationException(buildExceptionMessage(invalidProperties, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this.validatedBeanNames.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们开始debug:<br>前期是各种类的注入，异常是最后一步抛出来的，我们直接从最后一步开始</p><h1 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h1><p>factory.preInstantiateSingletons();<br>调用的是：DefaultListableBeanFactory.preInstantiateSingletons() line: 772<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">....</span><br><span class="line">getBean(beanName);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h1><p>调用DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 197<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object getBean(String name) throws BeansException &#123;</span><br><span class="line">return doGetBean(name, null, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h1><p>调用DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class<t>, Object[], boolean) line: 302<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">throws BeansException &#123;</span><br><span class="line">....</span><br><span class="line">sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return createBean(beanName, mbd, args);   //在回调方法里创建对象</span><br><span class="line">&#125;</span><br><span class="line">catch (BeansException ex) &#123;</span><br><span class="line">// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><h1 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h1><p>调用DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory&lt;?&gt;) line: 230<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">...</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h1><p>调用AbstractBeanFactory$1.getObject() line: 306    ，回到第三步的ObjectFactory.getObject方法</p><h1 id="第六步："><a href="#第六步：" class="headerlink" title="第六步："></a>第六步：</h1><p>DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 482<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第七步："><a href="#第七步：" class="headerlink" title="第七步："></a>第七步：</h1><p>调用DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 543<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">...</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第八步："><a href="#第八步：" class="headerlink" title="第八步："></a>第八步：</h1><p>调用DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).populateBean(String, RootBeanDefinition, BeanWrapper) line: 1214<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123;</span><br><span class="line">....</span><br><span class="line">boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">if (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">if (hasInstAwareBpps) &#123;</span><br><span class="line">for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); //调用RequiredAnnotationBeanPostProcessor.postProcessPropertyValues方法</span><br><span class="line">if (pvs == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>到此，走到RequiredAnnotationBeanPostProcessor.postProcessPropertyValues方法，处理抛出了异常。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果想要学习一个框架，第一步就是如何入手。怎样阅读spring源码呢，当然是从测试类入手啦！！！spring提供了非常全面的测试类，今天就从srping-beans.jar的RequiredAnnotationBeanPostProcessorTests测试类入手&lt;br&gt;下
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring源码 赏析：一</title>
    <link href="http://yoursite.com/2018/11/22/spring%E6%BA%90%E7%A0%81%E4%B8%80/"/>
    <id>http://yoursite.com/2018/11/22/spring源码一/</id>
    <published>2018-11-22T12:27:43.000Z</published>
    <updated>2018-11-25T10:31:41.859Z</updated>
    
    <content type="html"><![CDATA[<p>超级接口标记，指示bean有资格由Spring容器通过回调式方法通知特定框架对象。实际的方法签名由单独的子接口确定，但是通常应该只包含一个接受单个参数的空返回方法。<br></p><p>注意，仅实现{@link Aware}不提供默认功能。<br>相反，处理必须显式地完成，<br>例如{@link org.springframework.beans…config.BeanPostProcessor BeanPostProcessor}。</p><p>参见{@link org.springframework.context…ApplicationContextAwareProcessor}</p><p>以及{@link org.springframework.beans…..AbstractAutowireCapableBeanFactory}</p><p>处理{@code *Aware}}接口回调的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Marker superinterface indicating that a bean is eligible to be</span><br><span class="line"> * notified by the Spring container of a particular framework object</span><br><span class="line"> * through a callback-style method. Actual method signature is</span><br><span class="line"> * determined by individual subinterfaces, but should typically</span><br><span class="line"> * consist of just one void-returning method that accepts a single</span><br><span class="line"> * argument.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that merely implementing &#123;@link Aware&#125; provides no default</span><br><span class="line"> * functionality. Rather, processing must be done explicitly, for example</span><br><span class="line"> * in a &#123;@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor&#125;.</span><br><span class="line"> * Refer to &#123;@link org.springframework.context.support.ApplicationContextAwareProcessor&#125;</span><br><span class="line"> * and &#123;@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory&#125;</span><br><span class="line"> * for examples of processing &#123;@code *Aware&#125; interface callbacks.</span><br><span class="line"> *</span><br><span class="line"> * @author Chris Beams</span><br><span class="line"> * @since 3.1</span><br><span class="line"> */</span><br><span class="line">public interface Aware &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Java中isAssignableFrom的用法"><a href="#Java中isAssignableFrom的用法" class="headerlink" title="Java中isAssignableFrom的用法"></a>Java中isAssignableFrom的用法</h1><p>class1.isAssignableFrom(class2) 判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。如果是则返回 true；否则返回 false。如果该 Class 表示一个基本类型，且指定的 Class 参数正是该 Class 对象，则该方法返回 true；否则返回 false。<br>class2是不是class1的子类或者子接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String[] getBeanNamesForType(@Nullable ResolvableType type) &#123;</span><br><span class="line">boolean isFactoryType = false;</span><br><span class="line">if (type != null) &#123;</span><br><span class="line">Class&lt;?&gt; resolved = type.resolve();</span><br><span class="line">if (resolved != null &amp;&amp; FactoryBean.class.isAssignableFrom(resolved)) &#123;</span><br><span class="line">isFactoryType = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; matches = new ArrayList&lt;&gt;();</span><br><span class="line">for (Map.Entry&lt;String, Object&gt; entry : this.beans.entrySet()) &#123;</span><br><span class="line">String name = entry.getKey();</span><br><span class="line">Object beanInstance = entry.getValue();</span><br><span class="line">if (beanInstance instanceof FactoryBean &amp;&amp; !isFactoryType) &#123;</span><br><span class="line">Class&lt;?&gt; objectType = ((FactoryBean&lt;?&gt;) beanInstance).getObjectType();</span><br><span class="line">if (objectType != null &amp;&amp; (type == null || type.isAssignableFrom(objectType))) &#123;</span><br><span class="line">matches.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (type == null || type.isInstance(beanInstance)) &#123;</span><br><span class="line">matches.add(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return StringUtils.toStringArray(matches);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="spring-BeanDefinitionBuilder-建造者模式构造BeanDefinition"><a href="#spring-BeanDefinitionBuilder-建造者模式构造BeanDefinition" class="headerlink" title="spring  BeanDefinitionBuilder 建造者模式构造BeanDefinition"></a>spring  BeanDefinitionBuilder 建造者模式构造BeanDefinition</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinition beanDef = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(RequiredTestBean.class)</span><br><span class="line">.addPropertyValue(&quot;name&quot;, &quot;Rob Harrop&quot;)</span><br><span class="line">.addPropertyValue(&quot;favouriteColour&quot;, &quot;Blue&quot;)</span><br><span class="line">.addPropertyValue(&quot;jobTitle&quot;, &quot;Grand Poobah&quot;)</span><br><span class="line">.getBeanDefinition();</span><br></pre></td></tr></table></figure><h1 id="关于spring5-ReactiveAdapterRegistry-编译后报错需要jdk9"><a href="#关于spring5-ReactiveAdapterRegistry-编译后报错需要jdk9" class="headerlink" title="关于spring5 ReactiveAdapterRegistry 编译后报错需要jdk9"></a>关于spring5 ReactiveAdapterRegistry 编译后报错需要jdk9</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The type java.util.concurrent.Flow$Publisher cannot be resolved. It is indirectly referenced from required .class files</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;超级接口标记，指示bean有资格由Spring容器通过回调式方法通知特定框架对象。实际的方法签名由单独的子接口确定，但是通常应该只包含一个接受单个参数的空返回方法。&lt;br&gt;&lt;/p&gt;&lt;p&gt;注意，仅实现{@link Aware}不提供默认功能。&lt;br&gt;相反，处理必须显式地完成，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何基于hexo搭建博客</title>
    <link href="http://yoursite.com/2018/11/21/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/11/21/如何基于hexo搭建博客/</id>
    <published>2018-11-21T04:51:00.000Z</published>
    <updated>2018-11-21T05:10:58.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>基于hexo建站百度已有类似很多文章，我就不重复画瓢了。<br>不买服务器的话推荐gitee作为服务器托管。亲测gitee比github快10倍！！！</p><h1 id="hexo相关官方网站"><a href="#hexo相关官方网站" class="headerlink" title="hexo相关官方网站"></a>hexo相关官方网站</h1><p>我使用的hexo+gitee+next（主题）<br>   hexo：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br>   NexT（hexo主题）：<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">https://theme-next.iissnan.com/</a></p><hr><p>如有问题请加QQ群：<strong>793379854（计算机课设不会做）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;基于hexo建站百度已有类似很多文章，我就不重复画瓢了。&lt;br&gt;不买服务器的话推荐gitee作为服务器托管。亲测gitee比gith
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>搭建hexo遇到的问题</title>
    <link href="http://yoursite.com/2018/11/21/%E6%90%AD%E5%BB%BAhexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/21/搭建hexo遇到的问题/</id>
    <published>2018-11-21T01:19:18.000Z</published>
    <updated>2018-11-21T02:04:58.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何引用自己的文章"><a href="#如何引用自己的文章" class="headerlink" title="如何引用自己的文章"></a>如何引用自己的文章</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br><span class="line">例：&#123;% post_link  关于ShSx-G的由来 ShSx.G %&#125;</span><br></pre></td></tr></table></figure><h1 id="发布的图片太大（1M的图片在githubpage中卡的不能看）"><a href="#发布的图片太大（1M的图片在githubpage中卡的不能看）" class="headerlink" title="发布的图片太大（1M的图片在githubpage中卡的不能看）"></a>发布的图片太大（1M的图片在githubpage中卡的不能看）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我的解决方案是将图片压缩，我的用的一个在线压缩图片的网址是：https://tinypng.com/</span><br><span class="line">亲测1M的可以压到200k，图片清晰度还可以</span><br></pre></td></tr></table></figure><h1 id="nginx作为hexo的服务器访问503"><a href="#nginx作为hexo的服务器访问503" class="headerlink" title="nginx作为hexo的服务器访问503"></a>nginx作为hexo的服务器访问503</h1><p>因为没有文件的访问权限<br>测试nginx配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2ze88p52tbioqel09nmrz ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure></p><p>打开nginx.conf ,修改user nginx  为user root，然后重新载入配置文件<br>命令：nginx -s reload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user root;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br></pre></td></tr></table></figure></p><p>nginx其他常用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx                      # 启动 Nginx</span><br><span class="line">nginx -s reload            # 重新载入配置文件</span><br><span class="line">nginx -s reopen            # 重启 Nginx</span><br><span class="line">nginx -s stop              # 停止 Nginx</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何引用自己的文章&quot;&gt;&lt;a href=&quot;#如何引用自己的文章&quot; class=&quot;headerlink&quot; title=&quot;如何引用自己的文章&quot;&gt;&lt;/a&gt;如何引用自己的文章&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
